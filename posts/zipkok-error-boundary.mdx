---
title: "isError와 Error Boundary"
description: "isError와 Error Boundary의 차이점 그리고 Error Boundary가 잡을 수 없는 에러와 그 이유에 대해 알아봅니다."
date: "2025-10-02"
tags: ["Tanstack Query", "Error Boundary", "isError"]

published: true
---

## isError와 Error Boundary

React에서 데이터 패칭을 할 때 우리는 흔히 `isLoading`, `isError` 같은 상태값을 활용해 UI를 분기합니다.
로딩 스피너나 스켈레톤, 에러 UI를 통해 피드백을 주어야 사용자가 페이지가 멈춘 것이 아니라는 점을 인식할 수 있기 때문입니다.

저 또한 **Tanstack Query**의 `isError`, `isLoading`을 활용해 데이터 패칭 상태를 처리해왔지만,
**Suspense**와 **Error Boundary**를 조합하면 훨씬 더 간결한 방식으로 에러와 로딩을 처리할 수 있음을 알게되었습니다.

## isError

`isError`는 특정 쿼리/훅에서 발생한 데이터 패칭 관련 에러를 처리할 때 사용합니다.

Tanstack Query, SWR 같은 데이터 패칭 라이브러리는 `isError`, `isLoading`, `data`와 같은 상태를 제공하고, 우리는 이를 기반으로 조건 분기를 작성하게 됩니다.

```
const { data, isLoading, isError } = useQuery({queryKey: ["data"], queryFn: getData});

if (isLoading) return <LoadingSpinner />;
if (isError) return <ErrorMessage />;
return <DataView data={data} />;
```

이 방식은 직관적이지만, 컴포넌트마다 로딩/에러 분기가 반복된다는 단점이 있습니다.

### `isError`가 true가 되는 조건

데이터 패칭 라이브러리의 `isError`는 **HTTP 상태코드가 아닌 `Promise`의 상태**를 기준으로 동작합니다.

- **Promise Resolved** 상태면 `isError`는 `false`
- **Promise Rejected** 상태면 `isError`는 `true`

#### 네트워크 오류

인터넷 단절, CORS 차단, 서버 다운 등의 네트워크 오류는 HTTP 응답 자체가 없기 때문에 어떤 라이브러리든 `Promise`는 `rejected` 상태로 변경됩니다.

#### HTTP 에러

`fetch`의 경우 4xx,5xx 응답을 받더라도 정상적인 응답이라고 판단하기 때문에 `Promise`가 `resolved`상태로 유지됩니다.
따라서 **직접 에러처리를 해주지 않으면 `isError`는 `false`인 상태로 남게됩니다.**

반면 `axios`의 경우 2xx 이외의 응답 코드는 `Promise`를 `rejected` 상태로 변경합니다.
따라서 **에러처리를 해주지 않아도 `isError`는 `true`가 됩니다.**

## Error Boundary

`Error Boundary`는 React 렌더링 과정에서 발생하는 런타임 에러를 포착하여, 지정한 `fallback` UI를 보여주는 역할을 합니다.
기본적으로는 클래스 컴포넌트에서만 정의할 수 있지만, `react-error-boundary`라는 라이브러리를 사용하면 함수형 컴포넌트에서도 사용할 수 있습니다.

분기 로직을 컴포넌트에서 제거할 수 있어 비즈니스 로직에 집중할 수 있고, 특정 컴포넌트에서 에러가 발생하더라도 앱 전체가 멈추는 상황을 방지할 수 있습니다.

```
// 부모 레벨에서 감싸주면 하위 컴포넌트에서 발생하는 에러를 포착
<ErrorBoundary fallback={<ErrorView />}>
  <Suspense fallback={<LoadingView />}>
    <MyComponent />
  </Suspense>
</ErrorBoundary>

// 데이터 패칭 성공 케이스에만 집중
function MyComponent() {
  const { data } = useSuspenseQuery({ queryKey: ["data"], queryFn: getData });
  return <DataView data={data} />;
}
```

<br />
### Error Boundary에서 포착 가능한 에러

1. 렌더링 시점 에러

- 존재하지 않는 속성에 접근했을 때

```
function UserProfile({ user }: { user: any }) {
  return <div>{user.name.toUpperCase()}</div>; // user가 undefined면 에러
}
```

- 배열 메서드 호출 대상이 undefined/null일 때

```
posts.map(post => <Post key={post.id} />) // posts가 undefined면 TypeError
```

2. 잘못된 상태 업데이트

- `useState`로 관리되는 값이 예상치 못한 타입일 때

```
const [value, setValue] = useState<any>("");

const handleClick = () => {
  setValue(123); // TypeScript는 통과
};

return (
  <div>
    <p>문자열 길이: {value.length}</p> {/* 문자열로 기대 */}
    <button onClick={handleClick}>숫자로 변경</button>
  </div>
);
```

- 무한 루프를 유발하는 `setState` 호출

```
const [count, setCount] = useState(0);
setCount(count + 1); // 렌더링마다 실행되면 무한 루프
```

3. 이벤트 핸들러 및 비동기 에러

- 이벤트 핸들러에서 발생하는 에러

```
const handleClick = () => {
  try {
    // ... 코드
  } catch {
    throw new Error("버튼 클릭 에러!");
  }
};
```

### Error Boundary에서 포착하지 못하는 에러

Error Boundary는 렌더링 시점에서 발생하는 에러만 포착할 수 있고, 이벤트 핸들러나 비동기 콜백 내부의 에러, 서버사이드 렌더링, Error Boundary 자체에서 발생하는 에러는 포착할 수 없습니다.

아래는 잘못된 URL에 데이터를 요청했을 때의 예시입니다.

```
const AsyncErrorExample = () => {
  const [data, setData] = useState<any>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const res = await fetch("https://api.invalid-url.com/data");
        const data = await res.json();
        setData(json);
      } catch (error) {
        throw error;
      }
    };
    fetchData();
  }, [
```

잘못된 URL로 요청을 보내면, fetch는 Promise를 rejected 상태로 변경하고, 에러를 throw합니다.
하지만 에러 바운더리는 렌더링 시점에서 발생하는 에러만 포착할 수 있기 때문에, 이 에러를 포착할 수 없습니다.

그런데, `useState`를 통해 에러 상태를 관리한다면 상황은 달라집니다.

```
const AsyncErrorExample = () => {
  const [data, setData] = useState<any>(null);
  const [isError, setIsError] = useState(false);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const res = await fetch("https://api.invalid-url.com/data"); // 존재하지 않는 URL
        const data = await res.json();
        setData(data);
      } catch (error) {
        setIsError(true); // 상태로 에러 표시
      }
    };
    fetchData();
  }, []);

  if (isError) {
    throw new Error("Async 에러를 렌더링 단계에서 throw!");
  }
};
```

왜 try/catch 구문 내에서 발생한 에러는 에러 바운더리가 잡아내지 못하고, useState를 통해 에러 상태를 관리한 경우에만 에러를 포착할 수 있는 걸까요?
이는 **브라우저 환경에서의 동작 순서** 때문입니다.

## 브라우저와 비동기 동작 순서

브라우저의 자바스크립트 실행 환경은 크게 **자바스크립트 엔진(V8)**, **콜스택(Call Stack)**, 태스크 큐(Task Queue), **이벤트 루프(Event Loop)**, 그리고 **Web API**로 구성되어 있습니다.

> - **콜스택**: 실행 중인 함수(실행 컨텍스트)를 쌓아두는 공간
> - **Web API**: 브라우저가 제공하는 비동기 기능 (`setTimeout`, `fetch`, `DOM 이벤트` 등)
> - **태스크 큐**: 비동기 작업이 완료된 후 실행될 콜백을 저장하는 큐
> - **이벤트 루프**: 콜스택이 비면 태스크 큐에 쌓인 콜백을 다시 콜스택으로 전달
> - **실행 컨텍스트**: 함수가 실행될 때 생성되는 환경 정보(변수, 스코프 체인, this 등)

`AsyncErrorExample` 컴포넌트가 실행되면 브라우저 내부는 아래와 같은 순서로 동작합니다.

1. **초기 렌더링 및 비동기 요청**
   - `AsyncErrorExample` 컴포넌트가 처음 실행되고, `useEffect`가 마운트 됩니다.
   - `fetch` 요청이 Web API로 전달되고, 리액트는 콜스택에서 제거됩니다.

2. **비동기 에러 발생**
   - 잘못된 URL로 인해 `fetch`가 실패합니다.
   - Web API는 catch 블록 안의 콜백 함수를 태스크 큐에 추가합니다.

3. **이벤트 루프 동작**
   - 콜스택이 비면 이벤트 루프는 태스크 큐에 쌓인 콜백을 콜스택으로 전달합니다.
   - `setIsError(true)`가 호출 됩니다.

4. **리렌더링**
   - `setState`로 인해 리엑트가 다시 가동되고, `AsyncErrorExample` 컴포넌트를 다시 호출됩니다.
   - 리액트의 렌더링 컨텍스트가 다시 시작됩니다.

5. **에러 포착**
   - 리액트가 코드를 위에서 아래로 읽어내면서 `if(isError) {throw...}` 문을 만나게 됩니다.
   - 이 throw는 렌더링 단계에서 발생한 에러이므로 부모 컴포넌트의 Error Boundary에서 이를 포착하고 Fallback UI를 보여줍니다.

## Tanstack Query와 함께 사용하려면?

위의 이야기들을 통해 `isError`와 `Error Boundary`의 관계가 상호 보완적이라는 것은 알게 되었습니다.
그런데, 이 두가지를 함께 사용하려면 분기 코드와 Error Boundary 두 가지를 추가해야 하는 것일까요? 물론 아닙니다.

다행히 Tanstack Query에서 `useQuery({ suspense: true })` 또는 `useSuspenseQuery`를 사용하면 useState를 통해 에러 상태를 관리하지 않아도 비동기 에러를 잡아낼 수 있습니다.

## 마치며

지금까지 `isError`와 `Error Boundary`의 차이점과 Error Boundary가 잡을 수 없는 에러와 그 이유에 대해 알아보았습니다.
isError는 단일 컴포넌트 에러 처리에 적합하고, Error Boundary는 섹션 혹은 페이지 단위 에러처리에 적합합니다.

Error Boundary는 렌더링 시점에서 발생하는 에러만 포착할 수 있고, 이벤트 핸들러나 비동기 콜백 내부의 에러, 서버사이드 렌더링, Error Boundary 자체에서 발생하는 에러는 포착할 수 없습니다.
하지만 useState를 통해 리렌더링 단계에서 에러를 포착하거나, Tanstack Query 혹은 SWR을 사용하면 비동기 에러를 잡아낼 수 있습니다.

따라서 상황에 맞는 방법을 적절하게 사용하는 것이 중요합니다.

### Reference

- [ErrorBoundary 는 만능이 아니다?! 그럼 언제 ErrorBoundary 를 써야할까?](https://www.youtube.com/watch?v=v69zRgDCjjs&t=985s)
- [react-error-boundary로 에러 핸들링하기](https://developer-haru.tistory.com/86)
- [토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기](https://www.youtube.com/watch?v=FvRtoViujGg)
