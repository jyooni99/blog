---
title: "useState에서 React Hook Form으로 전환한 이유"
description: "useState로 폼을 관리하다가 겪은 문제점과 React Hook Form의 장점을 공유하고, 제어/비제어 컴포넌트 차이점과 React Hook Form의 동작 원리를 설명합니다."
date: "2025-03-20"
tags:
  ["React Hook Form", "Quick Network", "Controlled Component", "Uncontrolled Component"]
published: true
---

## 폼 관리, useState만으로 충분할까?

React에서 폼을 관리하는 가장 기본적인 방법은 `useState`입니다. 우리에게 가장 익숙하고 직관적이기 때문이죠.
프로젝트 초기. 빠른 개발을 위해 저 역시 `useState`를 사용해 폼 상태를 관리했었습니다.
하지만 **입력 필드와 유효성 검사 로직이 추가되면서 여러 문제점들이 발생**했습니다.

### 문제 상황1. 늘어나는 코드와 복잡한 로직

회원가입 과정에서 사용자에게 받는 필드는 총 11개입니다.

- **기본 정보**: 이름, 닉네임, 비밀번호, 이메일, 휴대폰 번호
- **직업 정보**: 소속, 직무/직책, 경력
- **네트워킹 참여 목적**: 네트워킹 참여 목적, 관심 직업, 관심 분야

사용자 경험을 고려해 폼을 **3단계 멀티 스텝 구조**로 나누었지만, 구조를 나눈 것만으로는 근본적인 문제가 해결되지 않았습니다.
필드가 하나 추가될 때마다 값을 변경하기 위한 `setField`, 에러 상태를 관리하기 위한 `errors`, 해당 값을 검증하기 위한 `validate` 로직을 함께 수정해야 했습니다.
또한 하나의 폼 컴포넌트 안에 **폼 상태 관리, 유효성 검사 로직, UI 렌더링, 제출 처리 및 페이지 이동 로직**까지 한데 모여있어 컴포넌트의 역할이 모호해졌고, **코드의 가독성과 유지보수성이 떨어졌습니다.**

아래는 당시 사용했던 `useState` 기반 예시 코드입니다.

```tsx
export default function JobForm() {
  const [form, setForm] = useState<FormData>({
    affiliation: "",
    job: null,
    career: null,
  });
  const [errors, setErrors] = useState<FormErrors>({});

  const setField = (field, value) => {
    setForm((prev) => ({ ...prev, [field]: value }));
  };

  const validate = () => {
    const newErrors: FormErrors = {};
    if (!form.affiliation.trim()) newErrors.affiliation = "소속을 입력해주세요.";
    if (!form.job) newErrors.job = "직무/직책을 선택해주세요.";
    return newErrors;
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    const newErrors = validate();
    if (Object.keys(newErrors).length > 0) return setErrors(newErrors);
    router.push("/register/network");
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={form.affiliation}
        onChange={(e) => setField("affiliation", e.target.value)}
      />
      {errors.affiliation && <p>{errors.affiliation}</p>}
      <Button type="submit">다음으로</Button>
    </form>
  );
}
```

스텝을 나누면서 코드의 길이는 줄어들었지만, 폼마다 반복되는 중복 코드와 로직이 복잡하게 얽혀있는 문제는 해결되지 않았습니다.

### 문제 상황2. 불필요한 리렌더링

또 다른 문제는 **불필요한 렌더링 문제**입니다.

각 입력 필드를 `useState`로 관리하면, 사용자가 값을 입력할 때마다 상태가 변경되고 컴포넌트가 리렌더링됩니다.
이 과정에서 이름 필드에 단 한 글자를 입력하는 것만으로도 `setForm`이 호출되고, `JobForm` 컴포넌트가 리렌더링됩니다.

문제는 **변경 사항이 전혀 없는 나머지 입력 필드들과 하위 컴포넌트들까지 모두 리렌더링**된다는 점입니다.

이러한 불필요한 리렌더링이 누적되면, **폼이 복잡해질수록 성능 저하로 이어질 수 있다**고 판단했고, 폼을 보다 효율적으로 관리할 수 있는 다른 방법들을 고민하게 되었습니다.

## React Hook Form을 도입한 이유?

`useState` 기반 폼 관리의 한계를 경험하면서, 폼을 전문적으로 관리해주는 도구의 필요성을 느끼게 되었고 **React Hook Form**을 도입하게 되었습니다.
React Hook Form의 주요 장점으로는 총 **3가지**가 있습니다.

### 1. 불필요한 리렌더링 최소화

React Hook Form은 기본적으로 **비제어(Uncontrolled) 컴포넌트** 방식을 사용합니다.
입력 값의 변경을 `useState`로 매번 추적하지 않고, DOM을 기준으로 값을 관리하기 때문에 입력할 때마다 컴포넌트 전체가 리렌더링되지 않습니다.

따라서 이름 필드에 텍스트를 입력하면, 해당 필드만 내부적으로 업데이트 되어 `JobForm` 컴포넌트가 리렌더링되지 않습니다.

### 2. 관심사의 분리

React Hook Form을 사용하면 컴포넌트의 역할을 명확하게 나눌 수 있습니다.

기존 `useState` 방식에서는 하나의 폼 컴포넌트가 모든 책임을 떠안고 있었지만, React Hook Form을 사용하면 역할이 자연스럽게 분리됩니다.

- 폼 상태 관리 → React Hook Form
- 유효성 검사 → register / resolver
- UI 렌더링 & 제출 처리 → 컴포넌트에 직접 구현

`register` 옵션을 통해 필드별 유효성 검사 규칙을 선언적으로 정의할 수 있고, `resolver`를 통해 Yup, Zod 같은 스키마 기반 검증이나 커스텀 유효성 검사를 적용할 수 있습니다.
이렇게 폼의 핵심 로직을 라이브러리에 위임하면서, 폼 컴포넌트는 **입력 UI와 사용자 흐름에만 집중하는 구조**로 바뀌게 됩니다.

### 3. 커스텀 컴포넌트와의 유연한 통합

마지막 장점은 **커스텀 컴포넌트와의 통합이 쉽고, 제어 컴포넌트와 비제어 컴포넌트를 함께 사용할 수 있다**는 점입니다.
React Hook Form은 기본적으로 비제어 컴포넌트 방식을 사용하지만, `Select`나 `DatePicker`와 같은 외부 UI 라이브러리, 혹은 내부 상태를 이미 가지고 있어 React가 값을 직접 관리해야 하는 컴포넌트의 경우에는 `Controller`를 통해 제어 컴포넌트로 사용할 수 있습니다.

또한 `useWatch`를 활용하면 특정 필드의 값만 구독할 수 있어, 다른 필드의 값에 따라 UI를 조건부로 변경하거나 일부 로직만 실시간으로 반응하도록 구성할 수 있습니다.

이 과정에서도 폼 전체가 리렌더링되지 않기 때문에, 성능과 유연성을 모두 챙길 수 있습니다.

## 제어 컴포넌트 vs 비제어 컴포넌트

React Hook Form의 장점을 이해하기 위해서는 **제어 컴포넌트(Controlled Component)와 비제어 컴포넌트(Uncontrolled Component)**의 차이를 먼저 짚고 넘어갈 필요가 있습니다.

### 제어 컴포넌트 (Controlled Component)

제어 컴포넌트는 **React의 `state`를 통해 입력 값을 관리하는 컴포넌트**입니다.

```tsx
const ControlledInput = () => {
  const [value, setValue] = useState("");

  return <input value={value} onChange={(e) => setValue(e.target.value)} />;
};
```

입력 값은 항상 React `state`에 저장되며, 사용자가 값을 변경할 때마다 `setState`가 호출되고 컴포넌트가 리렌더링됩니다.

이 방식의 장점은 입력 값을 실시간으로 제어하고 검증할 수 있다는 점입니다.

하지만 입력할 때마다 렌더링이 발생하기 때문에 **폼이 복잡해질수록 성능 부담이 커질 수 있습니다**.
또한 값을 실시간으로 관리하고 검증하기 위한 로직이 함께 추가되면서, 하나의 폼 컴포넌트가 과도하게 많은 책임을 가지게 됩니다.

앞서 살펴본 문제들 역시 이러한 **제어 컴포넌트 구조에서 비롯된 한계**라고 볼 수 있습니다.

### 비제어 컴포넌트 (Uncontrolled Component)

비제어 컴포넌트는 **DOM 자체에서 값을 관리하는 컴포넌트**입니다.

```tsx
const UncontrolledInput = () => {
  const inputRef = useRef<HTMLInputElement>(null);

  const handleSubmit = () => {
    console.log(inputRef.current?.value);
  };

  return <input ref={inputRef} defaultValue="기본값" />;
};
```

React에서는 `useRef`를 사용하여 DOM 요소에 직접 접근합니다.

비제어 컴포넌트는 입력 값을 React가 아니라 DOM이 직접 관리하기 때문에, **타이핑 중에 리렌더링이 발생하지 않고 성능이 좋다**는 장점이 있습니다.
간단한 입력 폼이라면 상태나 이벤트를 따로 관리하지 않아도 되기 때문에 구현도 빠르고 코드도 비교적 단순합니다.

하지만 입력 값이 React `state`로 관리되지 않기 때문에, 현재 입력 중인 값을 실시간으로 추적하기 어렵고,
유효성 검사를 하려면 submit 시점에 DOM에서 값을 직접 꺼내 처리해야 합니다.
외부 상태나 서버에서 받아온 초기값과 연동하기 위해서는 DOM 조작이나 추가 로직이 요구되기 때문에 오히려 코드가 더 복잡해질 수 있습니다.

**React Hook Form은 비제어 컴포넌트의 성능 이점을 활용하면서도 한계를 보완하는 구조**를 가지고 있습니다.

## React Hook Form은 어떻게 실시간 관리가 가능할까?

React Hook Form은 입력 값을 React `state`로 매번 관리하지 않습니다. 대신 DOM의 값과 내부 상태를 효율적으로 연결하는 방식을 사용합니다.
**입력 값은 DOM이 관리하지만, React Hook Form이 필요한 시점에 해당 값을 구독하고 참조**합니다.
따라서 값을 변경할 경우 폼 전체가 아닌 해당 필드 또는 구독중인 로직만 업데이트 됩니다.

이러한 구조 덕분에 비제어 컴포넌트 기반이지만, 실시간 유효성 검사와 조건부 UI 처리가 가능합니다.

## React Hook Form을 사용하여 리팩토링하기

기존의 복잡했던 `useState` 기반 폼 관리와 수동 유효성 검사 로직을 React Hook Form과 Zod 조합으로 리팩토링한 코드입니다.
그 결과, 각 컴포넌트는 유효성 검사 로직과 분리되어 UI 구조와 사용자 흐름에만 집중할 수 있는 구조로 개선되었습니다.

```tsx
export default function JobForm() {
  const methods = useForm<JobFormData>({
    mode: "onChange",
    resolver: zodResolver(jobFormSchema),
  });

  const {
    register,
    control,
    handleSubmit,
    formState: { isValid, errors },
  } = methods;

  const onSubmit = handleSubmit(useFormSubmit("/register/network"));

  return (
    <FormProvider {...methods}>
      <form onSubmit={onSubmit} className="flex flex-col gap-5">
        {/* 1. 일반 input: register를 통해 비제어 방식으로 연결 */}
        <div className="flex flex-col w-full">
          <label className="text-sm text-neutral-400">소속</label>
          <input
            {...register("affiliation")}
            placeholder="소속을 입력해주세요"
            className="border-none py-2 pl-3 rounded-md bg-neutral-700 text-neutral-400"
          />
          {errors.affiliation && (
            <p className="text-sm text-red-500 mt-2">{errors.affiliation.message}</p>
          )}
        </div>

        {/* 2. 커스텀 Select: 제어 방식이 필요한 경우 Controller 사용 */}
        <Controller
          name="job"
          control={control}
          render={({ field, fieldState }) => (
            <div className="flex flex-col w-full">
              <label className="text-sm text-neutral-400">직무 / 직책</label>
              <Select {...field} options={groupedJobOptions} styles={customStyles} />
              {fieldState.error && (
                <p className="text-sm text-red-500 mt-2">{fieldState.error.message}</p>
              )}
            </div>
          )}
        />

        <Button className="py-3" type="submit" disabled={!isValid}>
          다음으로
        </Button>
      </form>
    </FormProvider>
  );
}
```

## 마치며

지금까지 React Hook Form으로 전환하게 된 이유와 제어 컴포넌트와 비제어 컴포넌트의 차이점에 대해 살펴보았습니다.

**React Hook Form이 항상 정답은 아닙니다.**<br />
필드 수가 적은 단순한 폼이라면 `useState` 기반의 폼 관리만으로도 충분히 효과적일 수 있습니다.

하지만 **필드 수가 많아지고, 유효성 검사 규칙과 사용자 흐름이 복잡해질수록** 폼 상태 관리와 검증 로직이 점점 비대해지고, 잦은 리렌더링으로 인해 성능 저하가 발생할 가능성이 커집니다.

이런 상황에서 React Hook Form을 도입하면 폼 상태 관리와 유효성 검사 로직을 자연스럽게 분리할 수 있고, **코드의 가독성과 유지보수성을 높이면서도 불필요한 리렌더링을 줄여 성능까지 함께 개선**할 수 있습니다.

---

## Reference

- [React Hook Form 공식 문서](https://www.react-hook-form.com/)
- [React 공식문서: 비제어 컴포넌트](https://ko.legacy.reactjs.org/docs/uncontrolled-components.html)
